package com.takin.emmet.algo.first;

/**
 * 树形动规
 * 
 * 
 *
 * @since 
 * @see
 */
public class Dp3 {

    /**
     * 传说中的九头龙是一种特别贪吃的动物。虽然名字叫“九头龙”，但这只是说它出生的时候有九个头，而在成长的过程中，它有时会长出很多的新头，头的总数会远大于九，当然也会有旧头因衰老而自己脱落。有一天，有M个脑袋的九头龙看到一棵长有N个果子的果树，喜出望外，恨不得一口把它全部吃掉。可是必须照顾到每个头，因此它需要把N个果子分成M组，每组至少有一个果子，让每个头吃一组。这M个脑袋中有一个最大，称为“大头”，是众头之首，它要吃掉恰好K个果子，而且K个果子中理所当然地应该包括唯一的一个最大的果子。果子由N-1根树枝连接起来，由于果树是一个整体，因此可以从任意一个果子出发沿着树枝“走到”任何一个其他的果子。
              对于每段树枝，如果它所连接的两个果子需要由不同的头来吃掉，那么两个头会共同把树枝弄断而把果子分开；如果这两个果子是由同一个头来吃掉，那么这个头会懒得把它弄断而直接把果子连同树枝一起吃掉。当然，吃树枝并不是很舒服的，因此每段树枝都有一个吃下去的“难受值”，而九头龙的难受值就是所有头吃掉的树枝的“难受值”之和。
              九头龙希望它的“难受值”尽量小，你能帮它算算吗？
              例如图1所示的例子中，果树包含8个果子，7段树枝，各段树枝的“难受值”标记在了树枝的旁边。九头龙有两个脑袋，大头需要吃掉4个果子，其中必须包含最大的果子。即N=8，M=2，K=4：
              图一描述了果树的形态，图二描述了最优策略。
     */
    public static void eatingDragon() {

    }

    /**
     *        ７
    　　　　　　３　８
    　　　　　８　１　０
    　　　　２　７　４　４
    　　　４　５　２　６　５
            从顶点开始,每个数字向下层走只能有左下和右下两个方向,求出到达最后一行时的最大路径之和
     */
    public static void mathAngle() {

    }

}
